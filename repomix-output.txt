This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-29T21:37:49.476Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.gitignore
index.html
package.json
postcss.config.js
README.md
src/app.jsx
src/components/editor/Adjustments.jsx
src/components/editor/BatchProcessor.jsx
src/components/editor/Canvas.jsx
src/components/editor/ExportOptions.jsx
src/components/editor/FileUpload.jsx
src/components/editor/ImageCropper.jsx
src/components/editor/ImageEditor.jsx
src/components/editor/MultiImageManager.jsx
src/components/editor/ProjectsList.jsx
src/components/editor/SaveProjectDialog.jsx
src/components/layout/Header.jsx
src/components/layout/Sidebar.jsx
src/components/ui/button.jsx
src/components/ui/input.jsx
src/components/ui/progress.jsx
src/components/ui/slider.jsx
src/components/watermark/WatermarkDesigner.jsx
src/index.css
src/lib/utils.js
src/main.jsx
src/pages/Editor.jsx
src/pages/Home.jsx
src/pages/SavedProjects.jsx
src/pages/Settings.jsx
src/pages/Templates.jsx
src/services/projectService.js
src/store/editorStore.js
src/store/projectStore.js
src/store/userStore.js
src/store/watermarkStore.js
src/utils/image-export.js
src/utils/imageProcessing.js
tailwind.config.js
vite.config.js

================================================================
Repository Files
================================================================

================
File: .gitignore
================
node_modules
dist
.env
.env.local
.DS_Store
*.log

================
File: index.html
================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mom's Watermarker</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

================
File: package.json
================
{
    "name": "moms-watermarker",
    "private": true,
    "version": "1.0.0",
    "type": "module",
    "scripts": {
        "dev": "vite",
        "build": "vite build",
        "preview": "vite preview",
        "lint": "eslint src --ext js,jsx --report-unused-disable-directives --max-warnings 0"
    },
    "dependencies": {
        "@radix-ui/react-dialog": "^1.0.5",
        "@radix-ui/react-progress": "^1.0.3",
        "@radix-ui/react-slider": "^1.1.2",
        "class-variance-authority": "^0.7.0",
        "clsx": "^2.1.0",
        "lucide-react": "^0.263.1",
        "react": "^18.2.0",
        "react-dom": "^18.2.0",
        "react-dropzone": "^14.2.3",
        "react-router-dom": "^6.21.1",
        "tailwind-merge": "^2.2.0",
        "zustand": "^4.4.7"
    },
    "devDependencies": {
        "@types/react": "^18.2.43",
        "@types/react-dom": "^18.2.17",
        "@vitejs/plugin-react": "^4.2.1",
        "autoprefixer": "^10.4.20",
        "eslint": "^8.55.0",
        "eslint-plugin-react": "^7.33.2",
        "eslint-plugin-react-hooks": "^4.6.0",
        "eslint-plugin-react-refresh": "^0.4.5",
        "postcss": "^8.4.49",
        "tailwindcss": "^3.4.17",
        "vite": "^5.0.8"
    }
}

================
File: postcss.config.js
================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  }
}

================
File: README.md
================
# Mom's Watermarker
A powerful web-based platform for adding watermarks and editing photos.

## Setup
1. Install dependencies: `npm install`
2. Run `npm run dev` for development
3. Run `npm run build` for production build

================
File: src/app.jsx
================
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import Header from './components/layout/Header';
import Sidebar from './components/layout/Sidebar';
import Home from './pages/Home';
import Editor from './pages/Editor';
import Templates from './pages/Templates';
import Settings from './pages/Settings';
import SavedProjects from './pages/SavedProjects';

function App() {
  return (
    <Router>
      <div className="flex h-screen bg-gray-100">
        <Sidebar />
        <div className="flex-1 flex flex-col overflow-hidden">
          <Header />
          <main className="flex-1 overflow-x-hidden overflow-y-auto bg-gray-100">
          <Routes>
              <Route path="/" element={<Home />} />
              <Route path="/editor" element={<Editor />} />
              <Route path="/saved-projects" element={<SavedProjects />} />
              <Route path="/templates" element={<Templates />} />
              <Route path="/settings" element={<Settings />} />
            </Routes>
          </main>
        </div>
      </div>
    </Router>
  );
}

export default App;

================
File: src/components/editor/Adjustments.jsx
================
import React from 'react';
import { Slider } from '../ui/slider';
import { Button } from '../ui/button';
import { RotateCw, RefreshCw, Sun, Contrast, Droplet } from 'lucide-react';
import useEditorStore from '../../store/editorStore';

const Adjustments = () => {
  const { settings, updateSettings, resetSettings } = useEditorStore((state) => ({
    settings: state.settings,
    updateSettings: state.updateSettings,
    resetSettings: state.resetSettings,
  }));

  const adjustments = [
    {
      name: 'Brightness',
      key: 'brightness',
      icon: Sun,
      min: 0,
      max: 200,
      step: 1,
    },
    {
      name: 'Contrast',
      key: 'contrast',
      icon: Contrast,
      min: 0,
      max: 200,
      step: 1,
    },
    {
      name: 'Saturation',
      key: 'saturation',
      icon: Droplet,
      min: 0,
      max: 200,
      step: 1,
    },
    {
      name: 'Rotation',
      key: 'rotation',
      icon: RotateCw,
      min: 0,
      max: 360,
      step: 1,
    },
  ];

  return (
    <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-4">
      <div className="flex items-center justify-between mb-6">
        <h3 className="text-lg font-semibold text-gray-900">Image Adjustments</h3>
        <Button
          variant="outline"
          size="sm"
          onClick={resetSettings}
          className="flex items-center gap-2"
        >
          <RefreshCw className="w-4 h-4" />
          Reset
        </Button>
      </div>

      <div className="space-y-6">
        {adjustments.map((adjustment) => (
          <div key={adjustment.key}>
            <div className="flex items-center justify-between mb-2">
              <label className="flex items-center gap-2 text-sm font-medium text-gray-700">
                <adjustment.icon className="w-4 h-4" />
                {adjustment.name}
              </label>
              <span className="text-sm text-gray-500">
                {Math.round(settings[adjustment.key])}
                {adjustment.key === 'rotation' ? '°' : '%'}
              </span>
            </div>
            <Slider
              value={[settings[adjustment.key]]}
              min={adjustment.min}
              max={adjustment.max}
              step={adjustment.step}
              onValueChange={(value) =>
                updateSettings({ [adjustment.key]: value[0] })
              }
            />
          </div>
        ))}
      </div>

      <div className="grid grid-cols-2 gap-2 mt-6">
        <Button
          variant="outline"
          onClick={() =>
            updateSettings({
              rotation: (settings.rotation - 90 + 360) % 360,
            })
          }
        >
          Rotate Left
        </Button>
        <Button
          variant="outline"
          onClick={() =>
            updateSettings({
              rotation: (settings.rotation + 90) % 360,
            })
          }
        >
          Rotate Right
        </Button>
      </div>
    </div>
  );
};

export default Adjustments;

================
File: src/components/editor/BatchProcessor.jsx
================
import React, { useState } from 'react';
import { useDropzone } from 'react-dropzone';
import { Button } from '../ui/button';
import { Progress } from '../ui/progress';
import { Trash2, Upload, Play, Download } from 'lucide-react';
import { formatFileSize } from '../../lib/utils';

const BatchProcessor = ({ watermarkSettings, onProcess }) => {
  const [files, setFiles] = useState([]);
  const [processing, setProcessing] = useState(false);
  const [progress, setProgress] = useState(0);

  const { getRootProps, getInputProps } = useDropzone({
    accept: {
      'image/*': ['.jpeg', '.jpg', '.png', '.gif']
    },
    onDrop: (acceptedFiles) => {
      setFiles((prevFiles) => [...prevFiles, ...acceptedFiles]);
    },
  });

  const removeFile = (index) => {
    setFiles((prevFiles) => prevFiles.filter((_, i) => i !== index));
  };

  const processFiles = async () => {
    setProcessing(true);
    setProgress(0);

    const results = [];
    for (let i = 0; i < files.length; i++) {
      try {
        const result = await onProcess(files[i], watermarkSettings);
        results.push(result);
      } catch (error) {
        console.error(`Error processing ${files[i].name}:`, error);
      }
      setProgress(((i + 1) / files.length) * 100);
    }

    setProcessing(false);
    return results;
  };

  return (
    <div className="space-y-6">
      {/* Drop Zone */}
      <div
        {...getRootProps()}
        className="border-2 border-dashed rounded-lg p-6 text-center cursor-pointer hover:border-gray-400"
      >
        <input {...getInputProps()} />
        <Upload className="mx-auto h-12 w-12 text-gray-400" />
        <p className="mt-2 text-sm text-gray-600">
          Drag and drop images here, or click to select files
        </p>
      </div>

      {/* File List */}
      {files.length > 0 && (
        <div className="space-y-4">
          <h4 className="font-medium text-gray-900">
            {files.length} file(s) selected
          </h4>
          <div className="space-y-2">
            {files.map((file, index) => (
              <div
                key={index}
                className="flex items-center justify-between p-2 bg-gray-50 rounded-md"
              >
                <div className="flex items-center space-x-3">
                  <img
                    src={URL.createObjectURL(file)}
                    alt=""
                    className="h-10 w-10 object-cover rounded"
                  />
                  <div className="flex-1 min-w-0">
                    <p className="text-sm font-medium text-gray-900 truncate">
                      {file.name}
                    </p>
                    <p className="text-sm text-gray-500">
                      {formatFileSize(file.size)}
                    </p>
                  </div>
                </div>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => removeFile(index)}
                >
                  <Trash2 className="h-4 w-4 text-gray-500" />
                </Button>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Progress Bar */}
      {processing && (
        <div className="space-y-2">
          <Progress value={progress} />
          <p className="text-sm text-gray-600 text-center">
            Processing: {Math.round(progress)}%
          </p>
        </div>
      )}

      {/* Action Buttons */}
      <div className="flex space-x-3">
        <Button
          onClick={processFiles}
          disabled={files.length === 0 || processing}
          className="flex-1"
        >
          <Play className="h-4 w-4 mr-2" />
          Process Files
        </Button>
        <Button
          variant="outline"
          onClick={() => setFiles([])}
          disabled={files.length === 0 || processing}
        >
          Clear All
        </Button>
      </div>
    </div>
  );
};

export default BatchProcessor;

================
File: src/components/editor/Canvas.jsx
================
import React, { useEffect, useState, forwardRef } from 'react';
import useEditorStore from '../../store/editorStore';

const Canvas = forwardRef((props, ref) => {
  const [canvasDimensions, setCanvasDimensions] = useState({ width: 0, height: 0 });
  const [isLoading, setIsLoading] = useState(false);

  const {
    currentImage,
    settings,
    watermark,
    updateSettings
  } = useEditorStore((state) => ({
    currentImage: state.currentImage,
    settings: state.settings,
    watermark: state.watermark,
    updateSettings: state.updateSettings
  }));

  // Calculate canvas dimensions while maintaining aspect ratio
  const calculateCanvasDimensions = (img, maxWidth = 800) => {
    let width = img.naturalWidth;
    let height = img.naturalHeight;

    if (width > maxWidth) {
      const ratio = maxWidth / width;
      width = maxWidth;
      height = height * ratio;
    }

    return { width, height };
  };

  // Draw the image with all adjustments and watermark
  const drawCanvas = async () => {
    if (!currentImage || !ref.current) return;

    setIsLoading(true);
    const canvas = ref.current;
    const ctx = canvas.getContext('2d');

    // Create new image object
    const img = new Image();
    img.crossOrigin = 'anonymous';  // Handle CORS if needed

    img.onload = () => {
      try {
        // Calculate and set dimensions
        const dimensions = calculateCanvasDimensions(img);
        canvas.width = dimensions.width;
        canvas.height = dimensions.height;
        setCanvasDimensions(dimensions);

        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw base image
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

        setIsLoading(false);
      } catch (error) {
        console.error('Error drawing image:', error);
        setIsLoading(false);
      }
    };

    img.onerror = (error) => {
      console.error('Error loading image:', error);
      setIsLoading(false);
    };

    img.src = currentImage;
  };

  // Effect to handle image changes
  useEffect(() => {
    if (currentImage) {
      drawCanvas();
    }
  }, [currentImage]);

  // Handle canvas click for watermark positioning
  const handleCanvasClick = (e) => {
    if (!ref.current || !watermark.text) return;

    const canvas = ref.current;
    const rect = canvas.getBoundingClientRect();
    
    const x = ((e.clientX - rect.left) / rect.width) * 100;
    const y = ((e.clientY - rect.top) / rect.height) * 100;

    useEditorStore.getState().updateWatermark({
      position: { x, y }
    });
  };

  if (!currentImage) {
    return (
      <div className="w-full h-96 bg-gray-100 rounded-lg flex items-center justify-center">
        <span className="text-gray-500">No image selected</span>
      </div>
    );
  }

  return (
    <div className="relative w-full">
      {isLoading && (
        <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 rounded-lg">
          <div className="text-white">Processing...</div>
        </div>
      )}
      
      <canvas
        ref={ref}
        onClick={handleCanvasClick}
        className="max-w-full h-auto rounded-lg shadow-lg cursor-crosshair"
        style={{
          opacity: isLoading ? 0.5 : 1,
          transition: 'opacity 0.2s ease-in-out'
        }}
      />

      {canvasDimensions.width > 0 && (
        <div className="mt-2 text-sm text-gray-500 text-center">
          {`${Math.round(canvasDimensions.width)} × ${Math.round(canvasDimensions.height)} px`}
        </div>
      )}
    </div>
  );
});

Canvas.displayName = 'Canvas';

export default Canvas;

================
File: src/components/editor/ExportOptions.jsx
================
import React, { useState } from 'react';
import { Button } from '../ui/button';
import { Input } from '../ui/input';
import { Slider } from '../ui/slider';
import { Download, Settings2 } from 'lucide-react';
import { exportImageWithSettings } from '../../utils/image-export';

const ExportOptions = ({ canvasRef }) => {
  const [settings, setSettings] = useState({
    filename: 'watermarked-image',
    format: 'png',
    quality: 80,
    preserveMetadata: true,
  });

  const handleExport = async () => {
    if (!canvasRef?.current) {
      console.error('Canvas reference not available');
      return;
    }

    try {
      await exportImageWithSettings(canvasRef.current, settings);
    } catch (error) {
      console.error('Export failed:', error);
      // You might want to show an error message to the user here
    }
  };

  const formats = [
    { value: 'png', label: 'PNG' },
    { value: 'jpeg', label: 'JPEG' },
    { value: 'webp', label: 'WebP' },
  ];

  return (
    <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-4">
      <div className="flex items-center gap-2 mb-6">
        <Settings2 className="w-5 h-5 text-gray-500" />
        <h3 className="text-lg font-semibold text-gray-900">Export Settings</h3>
      </div>

      <div className="space-y-4">
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Filename
          </label>
          <Input
            type="text"
            value={settings.filename}
            onChange={(e) =>
              setSettings((prev) => ({ ...prev, filename: e.target.value }))
            }
          />
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Format
          </label>
          <select
            className="w-full rounded-md border border-gray-300 py-2 px-3"
            value={settings.format}
            onChange={(e) =>
              setSettings((prev) => ({ ...prev, format: e.target.value }))
            }
          >
            {formats.map((format) => (
              <option key={format.value} value={format.value}>
                {format.label}
              </option>
            ))}
          </select>
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Quality ({settings.quality}%)
          </label>
          <Slider
            value={[settings.quality]}
            min={1}
            max={100}
            step={1}
            onValueChange={(value) =>
              setSettings((prev) => ({ ...prev, quality: value[0] }))
            }
          />
        </div>

        <div className="flex items-center">
          <input
            type="checkbox"
            id="preserveMetadata"
            checked={settings.preserveMetadata}
            onChange={(e) =>
              setSettings((prev) => ({
                ...prev,
                preserveMetadata: e.target.checked,
              }))
            }
            className="rounded border-gray-300 text-blue-600 focus:ring-blue-500 h-4 w-4"
          />
          <label
            htmlFor="preserveMetadata"
            className="ml-2 block text-sm text-gray-700"
          >
            Preserve image metadata
          </label>
        </div>

        <Button
          onClick={handleExport}
          className="w-full flex items-center justify-center gap-2"
        >
          <Download className="w-4 h-4" />
          Export Image
        </Button>
      </div>
    </div>
  );
};

export default ExportOptions;

================
File: src/components/editor/FileUpload.jsx
================
import React, { useCallback } from 'react';
import { useDropzone } from 'react-dropzone';
import { Upload, Image as ImageIcon } from 'lucide-react';
import { Button } from '../ui/button';
import { formatFileSize } from '../../lib/utils';
import useEditorStore from '../../store/editorStore';

const FileUpload = () => {
  const setCurrentImage = useEditorStore((state) => state.setCurrentImage);

  const onDrop = useCallback(async (acceptedFiles) => {
    const file = acceptedFiles[0];
    if (file) {
      try {
        // Create a new FileReader
        const reader = new FileReader();
        
        // Create a promise to handle the file reading
        const imageLoadPromise = new Promise((resolve, reject) => {
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
        });

        // Start reading the file
        reader.readAsDataURL(file);

        // Wait for the file to be read
        const result = await imageLoadPromise;
        
        // Create an image to verify it loads correctly
        const img = new Image();
        const imageVerifyPromise = new Promise((resolve, reject) => {
          img.onload = () => resolve(result);
          img.onerror = reject;
        });
        img.src = result;

        // Wait for image to load and then set it in store
        const verifiedImage = await imageVerifyPromise;
        setCurrentImage(verifiedImage);
      } catch (error) {
        console.error('Error loading image:', error);
        // Here you might want to show an error message to the user
      }
    }
  }, [setCurrentImage]);

  const { getRootProps, getInputProps, isDragActive, acceptedFiles } = useDropzone({
    onDrop,
    accept: {
      'image/*': ['.jpeg', '.jpg', '.png', '.gif']
    },
    maxFiles: 1,
    multiple: false
  });

  return (
    <div>
      <div
        {...getRootProps()}
        className={`border-2 border-dashed rounded-lg p-8 text-center cursor-pointer transition-colors
          ${isDragActive 
            ? 'border-blue-500 bg-blue-50' 
            : 'border-gray-300 hover:border-gray-400'
          }`}
      >
        <input {...getInputProps()} />
        
        <div className="flex flex-col items-center space-y-4">
          {acceptedFiles.length > 0 ? (
            <>
              <ImageIcon className="w-12 h-12 text-gray-400" />
              <div className="text-sm text-gray-600">
                {acceptedFiles[0].name} ({formatFileSize(acceptedFiles[0].size)})
              </div>
              <Button variant="outline" size="sm">
                Choose Another Image
              </Button>
            </>
          ) : (
            <>
              <Upload className="w-12 h-12 text-gray-400" />
              <div>
                <p className="text-lg font-medium text-gray-900">
                  Drop your image here
                </p>
                <p className="text-sm text-gray-500 mt-1">
                  or click to select a file
                </p>
              </div>
              <p className="text-xs text-gray-500">
                Supports: JPG, JPEG, PNG, GIF
              </p>
            </>
          )}
        </div>
      </div>

      {acceptedFiles.length > 0 && (
        <div className="mt-4 flex justify-end">
          <Button 
            onClick={() => onDrop(acceptedFiles)}
            className="flex items-center gap-2"
          >
            <ImageIcon className="w-4 h-4" />
            Edit Image
          </Button>
        </div>
      )}
    </div>
  );
};

export default FileUpload;

================
File: src/components/editor/ImageCropper.jsx
================
import React, { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Crop, Check, X } from 'lucide-react';
import Canvas from './Canvas';
import useEditorStore from '../../store/editorStore';

const ImageCropper = ({ canvasRef }) => {
  const { settings, updateSettings } = useEditorStore((state) => ({
    settings: state.settings,
    updateSettings: state.updateSettings
  }));

  const [startPos, setStartPos] = useState(null);
  const [isDragging, setIsDragging] = useState(false);

  const startCropping = () => {
    if (canvasRef.current) {
      const canvas = canvasRef.current;
      updateSettings({
        isCropping: true,
        cropBox: {
          x: 0,
          y: 0,
          width: canvas.width,
          height: canvas.height
        }
      });
    }
  };

  const handleMouseDown = (e) => {
    if (!settings.isCropping) return;

    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    setStartPos({
      x: (e.clientX - rect.left) * scaleX,
      y: (e.clientY - rect.top) * scaleY
    });
    setIsDragging(true);
  };

  const handleMouseMove = (e) => {
    if (!isDragging || !startPos || !canvasRef.current) return;

    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    const currentX = (e.clientX - rect.left) * scaleX;
    const currentY = (e.clientY - rect.top) * scaleY;

    updateSettings({
      cropBox: {
        x: Math.min(startPos.x, currentX),
        y: Math.min(startPos.y, currentY),
        width: Math.abs(currentX - startPos.x),
        height: Math.abs(currentY - startPos.y)
      }
    });
  };

  const handleMouseUp = () => {
    setIsDragging(false);
  };

  const applyCrop = () => {
    if (!canvasRef.current) return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    
    // Create temporary canvas with cropped image
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = settings.cropBox.width;
    tempCanvas.height = settings.cropBox.height;
    const tempCtx = tempCanvas.getContext('2d');
    
    // Copy the cropped portion
    tempCtx.drawImage(
      canvas,
      settings.cropBox.x, settings.cropBox.y, 
      settings.cropBox.width, settings.cropBox.height,
      0, 0, settings.cropBox.width, settings.cropBox.height
    );
    
    // Clear original canvas and resize it
    canvas.width = settings.cropBox.width;
    canvas.height = settings.cropBox.height;
    
    // Draw cropped image back
    ctx.drawImage(tempCanvas, 0, 0);
    
    // Reset cropping state
    updateSettings({
      isCropping: false,
      cropBox: { x: 0, y: 0, width: 0, height: 0 }
    });
  };

  const cancelCrop = () => {
    updateSettings({
      isCropping: false,
      cropBox: { x: 0, y: 0, width: 0, height: 0 }
    });
  };

  // Draw crop overlay
  useEffect(() => {
    if (settings.isCropping && canvasRef.current) {
      const canvas = canvasRef.current;
      const ctx = canvas.getContext('2d');
      
      // Store the original image data
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      
      const drawOverlay = () => {
        // Restore the original image
        ctx.putImageData(imageData, 0, 0);
        
        // Draw semi-transparent overlay
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Clear crop area
        ctx.clearRect(
          settings.cropBox.x, 
          settings.cropBox.y, 
          settings.cropBox.width, 
          settings.cropBox.height
        );
        
        // Draw crop border
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(
          settings.cropBox.x, 
          settings.cropBox.y, 
          settings.cropBox.width, 
          settings.cropBox.height
        );
      };

      drawOverlay();

      return () => {
        // Restore the original image when unmounting or when crop mode ends
        ctx.putImageData(imageData, 0, 0);
      };
    }
  }, [settings.isCropping, settings.cropBox]);

  return (
    <div className="relative">
      <div 
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
        className={settings.isCropping ? 'cursor-crosshair' : ''}
      >
        <Canvas ref={canvasRef} />
      </div>
      
      <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 flex gap-2">
        {!settings.isCropping ? (
          <Button
            onClick={startCropping}
            variant="default"
            className="flex items-center gap-2"
          >
            <Crop className="w-4 h-4" />
            Crop Image
          </Button>
        ) : (
          <>
            <Button
              onClick={applyCrop}
              variant="default"
              className="flex items-center gap-2"
            >
              <Check className="w-4 h-4" />
              Apply Crop
            </Button>
            <Button
              onClick={cancelCrop}
              variant="destructive"
              className="flex items-center gap-2"
            >
              <X className="w-4 h-4" />
              Cancel
            </Button>
          </>
        )}
      </div>
    </div>
  );
};

export default ImageCropper;

================
File: src/components/editor/ImageEditor.jsx
================
import React from 'react';
import FileUpload from './FileUpload';
import WatermarkDesigner from '../watermark/WatermarkDesigner';
import ImageCropper from './ImageCropper';
import useEditorStore from '../../store/editorStore';

const ImageEditor = ({ canvasRef }) => {
  const currentImage = useEditorStore((state) => state.currentImage);

  return (
    <div className="h-full flex flex-col">
      {!currentImage ? (
        <div className="flex-1 flex items-center justify-center p-8">
          <FileUpload />
        </div>
      ) : (
        <div className="flex-1 flex gap-4 p-4">
          <div className="flex-1">
            <ImageCropper canvasRef={canvasRef} />
          </div>
          <div className="w-80">
            <WatermarkDesigner />
          </div>
        </div>
      )}
    </div>
  );
};

export default ImageEditor;

================
File: src/components/editor/MultiImageManager.jsx
================
import React, { useCallback } from 'react';
import { useDropzone } from 'react-dropzone';
import { Button } from '@/components/ui/button';
import { Progress } from '@/components/ui/progress';
import { Upload, Trash2, Image as ImageIcon, Edit2 } from 'lucide-react';
import { formatFileSize } from '@/lib/utils';
import useEditorStore from '@/store/editorStore';

const MultiImageManager = () => {
  const { projectImages, addImages, removeImage, setCurrentImage } = useEditorStore();

  const onDrop = useCallback((acceptedFiles) => {
    const imagePromises = acceptedFiles.map(file => {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = (event) => {
          resolve(event.target.result);
        };
        reader.readAsDataURL(file);
      });
    });

    Promise.all(imagePromises).then(images => {
      addImages(images);
    });
  }, [addImages]);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      'image/*': ['.jpeg', '.jpg', '.png', '.gif']
    },
    multiple: true
  });

  return (
    <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-4">
      <h3 className="text-lg font-semibold text-gray-900 mb-4">Project Images</h3>

      {/* Drop Zone */}
      <div
        {...getRootProps()}
        className={`border-2 border-dashed rounded-lg p-4 text-center cursor-pointer ${
          isDragActive ? 'border-blue-500 bg-blue-50' : 'border-gray-300'
        }`}
      >
        <input {...getInputProps()} />
        <Upload className="mx-auto h-8 w-8 text-gray-400" />
        <p className="mt-2 text-sm text-gray-500">
          Drop images here or click to select
        </p>
      </div>

      {/* Images List */}
      {projectImages.length > 0 && (
        <div className="mt-4 space-y-2">
          <div className="flex justify-between items-center mb-2">
            <span className="text-sm font-medium text-gray-700">
              {projectImages.length} images in project
            </span>
          </div>

          <div className="space-y-2 max-h-96 overflow-y-auto">
            {projectImages.map((image, index) => (
              <div
                key={index}
                className="flex items-center justify-between p-2 bg-gray-50 rounded-md"
              >
                <div className="flex items-center space-x-3">
                  <img
                    src={image}
                    alt={`Project image ${index + 1}`}
                    className="h-12 w-12 object-cover rounded"
                  />
                  <div>
                    <p className="text-sm font-medium text-gray-900">
                      Image {index + 1}
                    </p>
                  </div>
                </div>

                <div className="flex items-center gap-2">
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => setCurrentImage(image)}
                    className="text-blue-600"
                  >
                    <Edit2 className="h-4 w-4" />
                  </Button>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => removeImage(index)}
                    className="text-red-600"
                  >
                    <Trash2 className="h-4 w-4" />
                  </Button>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};

export default MultiImageManager;

================
File: src/components/editor/ProjectsList.jsx
================
import React, { useEffect } from 'react';
import { Button } from '../ui/button';
import { Edit2, Trash2, Clock, Image as ImageIcon } from 'lucide-react';
import useProjectStore from '../../store/projectStore';

const ProjectsList = ({ onProjectSelect }) => {
  const { projects, fetchProjects, deleteProject, isLoading } = useProjectStore();

  useEffect(() => {
    fetchProjects();
  }, [fetchProjects]);

  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-48">
        <div className="text-gray-500">Loading projects...</div>
      </div>
    );
  }

  if (projects.length === 0) {
    return (
      <div className="text-center py-8">
        <ImageIcon className="mx-auto h-12 w-12 text-gray-400" />
        <h3 className="mt-2 text-sm font-medium text-gray-900">No projects</h3>
        <p className="mt-1 text-sm text-gray-500">
          Get started by creating a new project
        </p>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {projects.map((project) => (
        <div
          key={project.id}
          className="bg-white rounded-lg shadow-sm border border-gray-200 p-4"
        >
          <div className="flex items-start justify-between">
            <div className="flex-1 min-w-0">
              <h3 className="text-lg font-semibold text-gray-900 truncate">
                {project.name}
              </h3>
              {project.description && (
                <p className="mt-1 text-sm text-gray-500 line-clamp-2">
                  {project.description}
                </p>
              )}
              <div className="mt-2 flex items-center text-sm text-gray-500">
                <Clock className="flex-shrink-0 mr-1.5 h-4 w-4" />
                Last modified: {formatDate(project.lastModified)}
              </div>
            </div>

            <div className="flex items-center gap-2 ml-4">
              <Button
                variant="ghost"
                size="sm"
                onClick={() => onProjectSelect(project)}
                className="text-blue-600"
              >
                <Edit2 className="h-4 w-4" />
              </Button>
              <Button
                variant="ghost"
                size="sm"
                onClick={() => deleteProject(project.id)}
                className="text-red-600"
              >
                <Trash2 className="h-4 w-4" />
              </Button>
            </div>
          </div>

          {project.imageData && (
            <div className="mt-4 flex justify-center">
              <img
                src={project.imageData}
                alt={project.name}
                className="h-24 w-40 object-cover rounded-md"
              />
            </div>
          )}
        </div>
      ))}
    </div>
  );
};

export default ProjectsList;

================
File: src/components/editor/SaveProjectDialog.jsx
================
import React, { useState } from 'react';
import * as Dialog from '@radix-ui/react-dialog';
import { X } from 'lucide-react';
import { Button } from '../ui/button';
import { Input } from '../ui/input';
import useProjectStore from '../../store/projectStore';
import useEditorStore from '../../store/editorStore';

const SaveProjectDialog = ({ open, onOpenChange }) => {
  const [projectName, setProjectName] = useState('');
  const [description, setDescription] = useState('');
  const [isSaving, setIsSaving] = useState(false);

  const { createProject, updateProject } = useProjectStore();
  const { currentImage, settings, watermark } = useEditorStore();

  const handleSave = async (e) => {
    e.preventDefault();
    setIsSaving(true);

    try {
      const projectData = {
        name: projectName,
        description,
        imageData: currentImage,
        settings,
        watermark,
        createdAt: new Date().toISOString(),
      };

      await createProject(projectData);
      onOpenChange(false);
      setProjectName('');
      setDescription('');
    } catch (error) {
      console.error('Error saving project:', error);
    } finally {
      setIsSaving(false);
    }
  };

  return (
    <Dialog.Root open={open} onOpenChange={onOpenChange}>
      <Dialog.Portal>
        <Dialog.Overlay className="fixed inset-0 bg-black/50" />
        <Dialog.Content className="fixed left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-full max-w-md bg-white rounded-lg p-6 shadow-xl">
          <div className="flex items-center justify-between mb-4">
            <Dialog.Title className="text-lg font-semibold">
              Save Project
            </Dialog.Title>
            <Dialog.Close className="rounded-full p-1.5 hover:bg-gray-100">
              <X className="h-4 w-4" />
            </Dialog.Close>
          </div>

          <form onSubmit={handleSave} className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Project Name
              </label>
              <Input
                type="text"
                value={projectName}
                onChange={(e) => setProjectName(e.target.value)}
                placeholder="Enter project name"
                required
              />
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Description
              </label>
              <textarea
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                placeholder="Optional project description"
                className="w-full rounded-md border border-gray-300 px-3 py-2 placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                rows={3}
              />
            </div>

            <div className="flex justify-end gap-3 mt-6">
              <Button
                type="button"
                variant="outline"
                onClick={() => onOpenChange(false)}
              >
                Cancel
              </Button>
              <Button type="submit" disabled={isSaving}>
                {isSaving ? 'Saving...' : 'Save Project'}
              </Button>
            </div>
          </form>
        </Dialog.Content>
      </Dialog.Portal>
    </Dialog.Root>
  );
};

export default SaveProjectDialog;

================
File: src/components/layout/Header.jsx
================
import React from 'react';
import { Link } from 'react-router-dom';
import { Button } from '../ui/button';
import { Upload, Settings as SettingsIcon } from 'lucide-react';

const Header = () => {
  return (
    <header className="bg-white shadow-sm">
      <div className="mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex h-16 justify-between items-center">
          <div className="flex items-center">
            <Link to="/" className="flex items-center">
              <h1 className="text-xl font-bold text-gray-900">Mom's Watermarker</h1>
            </Link>
          </div>
          
          <div className="flex items-center gap-4">
            <Button variant="outline" className="flex items-center gap-2">
              <Upload size={20} />
              Upload Image
            </Button>
            
            <Link to="/settings">
              <Button variant="ghost" size="icon">
                <SettingsIcon size={20} />
              </Button>
            </Link>
          </div>
        </div>
      </div>
    </header>
  );
};

export default Header;

================
File: src/components/layout/Sidebar.jsx
================
import React from 'react';
import { Link, useLocation } from 'react-router-dom';
import { Home, Image, Layout, Settings, FolderOpen } from 'lucide-react';

const Sidebar = () => {
  const location = useLocation();

  const navigationItems = [
    { name: 'Home', icon: Home, path: '/' },
    { name: 'Editor', icon: Image, path: '/editor' },
    { name: 'Saved Projects', icon: FolderOpen, path: '/saved-projects' },
    { name: 'Templates', icon: Layout, path: '/templates' },
    { name: 'Settings', icon: Settings, path: '/settings' },
  ];

  const isActivePath = (path) => {
    return location.pathname === path;
  };

  return (
    <div className="hidden sm:flex w-64 flex-col bg-white border-r border-gray-200">
      <div className="flex-1 flex flex-col pt-5 pb-4">
        <nav className="mt-5 flex-1 px-2 space-y-1">
          {navigationItems.map((item) => {
            const IconComponent = item.icon;
            return (
              <Link
                key={item.name}
                to={item.path}
                className={`group flex items-center px-2 py-2 text-sm font-medium rounded-md ${
                  isActivePath(item.path)
                    ? 'bg-gray-100 text-gray-900'
                    : 'text-gray-600 hover:bg-gray-50 hover:text-gray-900'
                }`}
              >
                <IconComponent
                  className={`mr-3 h-6 w-6 ${
                    isActivePath(item.path)
                      ? 'text-gray-500'
                      : 'text-gray-400 group-hover:text-gray-500'
                  }`}
                />
                {item.name}
              </Link>
            );
          })}
        </nav>
      </div>
    </div>
  );
};

export default Sidebar;

================
File: src/components/ui/button.jsx
================
import * as React from "react"
import { cva } from "class-variance-authority"
import { cn } from "../../lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "underline-offset-4 hover:underline text-primary",
      },
      size: {
        default: "h-10 py-2 px-4",
        sm: "h-9 px-3 rounded-md",
        lg: "h-11 px-8 rounded-md",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const Button = React.forwardRef(({ className, variant, size, ...props }, ref) => {
  return (
    <button
      className={cn(buttonVariants({ variant, size, className }))}
      ref={ref}
      {...props}
    />
  )
})
Button.displayName = "Button"

export { Button, buttonVariants }

================
File: src/components/ui/input.jsx
================
import * as React from "react"
import { cn } from "../../lib/utils"

const Input = React.forwardRef(({ className, type, ...props }, ref) => {
  return (
    <input
      type={type}
      className={cn(
        "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Input.displayName = "Input"

export { Input }

================
File: src/components/ui/progress.jsx
================
import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"
import { cn } from "../../lib/utils"

const Progress = React.forwardRef(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-2 w-full overflow-hidden rounded-full bg-gray-100",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-blue-500 transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }

================
File: src/components/ui/slider.jsx
================
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"
import { cn } from "../../lib/utils"

const Slider = React.forwardRef(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }

================
File: src/components/watermark/WatermarkDesigner.jsx
================
import React from 'react';
import { Button } from '../ui/button';
import { Input } from '../ui/input';
import { Slider } from '../ui/slider';
import { Type, Move, RotateCw, Save, Sliders, AlignLeft, AlignCenter, AlignRight } from 'lucide-react';
import useEditorStore from '../../store/editorStore';

const WatermarkDesigner = () => {
  const { watermark, updateWatermark } = useEditorStore((state) => ({
    watermark: state.watermark,
    updateWatermark: state.updateWatermark
  }));

  const handleChange = (field, value) => {
    updateWatermark({ [field]: value });
  };

  const fontOptions = [
    'Arial',
    'Times New Roman',
    'Georgia',
    'Verdana',
    'Helvetica',
    'Courier New',
    'Impact'
  ];

  const alignmentOptions = [
    { value: 'left', icon: AlignLeft },
    { value: 'center', icon: AlignCenter },
    { value: 'right', icon: AlignRight }
  ];

  return (
    <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-4">
      <div className="space-y-6">
        {/* Text Settings */}
        <div>
          <h3 className="text-sm font-medium text-gray-900 flex items-center gap-2 mb-4">
            <Type className="w-4 h-4" />
            Text Settings
          </h3>
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Watermark Text
              </label>
              <Input
                type="text"
                value={watermark.text}
                onChange={(e) => handleChange('text', e.target.value)}
                placeholder="Enter watermark text..."
              />
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Font Family
              </label>
              <select
                className="w-full rounded-md border border-gray-300 py-2 px-3"
                value={watermark.font}
                onChange={(e) => handleChange('font', e.target.value)}
              >
                {fontOptions.map((font) => (
                  <option key={font} value={font}>
                    {font}
                  </option>
                ))}
              </select>
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Font Size ({watermark.size}px)
              </label>
              <Slider
                value={[watermark.size]}
                min={12}
                max={120}
                step={1}
                onValueChange={(value) => handleChange('size', value[0])}
              />
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Color
              </label>
              <div className="flex items-center gap-2">
                <Input
                  type="color"
                  value={watermark.color}
                  onChange={(e) => handleChange('color', e.target.value)}
                  className="h-10 w-20"
                />
                <Input
                  type="text"
                  value={watermark.color}
                  onChange={(e) => handleChange('color', e.target.value)}
                  className="flex-1"
                  placeholder="#FFFFFF"
                />
              </div>
            </div>
          </div>
        </div>

        {/* Position & Alignment */}
        <div>
          <h3 className="text-sm font-medium text-gray-900 flex items-center gap-2 mb-4">
            <Move className="w-4 h-4" />
            Position & Alignment
          </h3>
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Alignment
              </label>
              <div className="flex gap-2">
                {alignmentOptions.map(({ value, icon: Icon }) => (
                  <Button
                    key={value}
                    variant={watermark.alignment === value ? 'default' : 'outline'}
                    className="flex-1"
                    onClick={() => handleChange('alignment', value)}
                  >
                    <Icon className="w-4 h-4" />
                  </Button>
                ))}
              </div>
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Horizontal Position ({watermark.position.x}%)
              </label>
              <Slider
                value={[watermark.position.x]}
                min={0}
                max={100}
                step={1}
                onValueChange={(value) =>
                  handleChange('position', { ...watermark.position, x: value[0] })
                }
              />
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Vertical Position ({watermark.position.y}%)
              </label>
              <Slider
                value={[watermark.position.y]}
                min={0}
                max={100}
                step={1}
                onValueChange={(value) =>
                  handleChange('position', { ...watermark.position, y: value[0] })
                }
              />
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Rotation ({watermark.rotation}°)
              </label>
              <Slider
                value={[watermark.rotation]}
                min={0}
                max={360}
                step={1}
                onValueChange={(value) => handleChange('rotation', value[0])}
              />
            </div>
          </div>
        </div>

        {/* Style Settings */}
        <div>
          <h3 className="text-sm font-medium text-gray-900 flex items-center gap-2 mb-4">
            <Sliders className="w-4 h-4" />
            Style Settings
          </h3>
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Opacity ({Math.round(watermark.opacity * 100)}%)
              </label>
              <Slider
                value={[watermark.opacity * 100]}
                min={0}
                max={100}
                step={1}
                onValueChange={(value) => handleChange('opacity', value[0] / 100)}
              />
            </div>

            <div className="flex items-center gap-2">
              <input
                type="checkbox"
                id="enableShadow"
                checked={watermark.enableShadow}
                onChange={(e) => handleChange('enableShadow', e.target.checked)}
                className="rounded border-gray-300"
              />
              <label
                htmlFor="enableShadow"
                className="text-sm font-medium text-gray-700"
              >
                Enable Shadow
              </label>
            </div>

            {watermark.enableShadow && (
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Shadow Opacity ({Math.round(watermark.shadowOpacity * 100)}%)
                </label>
                <Slider
                  value={[watermark.shadowOpacity * 100]}
                  min={0}
                  max={100}
                  step={1}
                  onValueChange={(value) =>
                    handleChange('shadowOpacity', value[0] / 100)
                  }
                />
              </div>
            )}
          </div>
        </div>

        {/* Save Template Button */}
        <Button
          className="w-full flex items-center justify-center gap-2"
          variant="outline"
        >
          <Save className="w-4 h-4" />
          Save as Template
        </Button>
      </div>
    </div>
  );
};

export default WatermarkDesigner;

================
File: src/index.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

================
File: src/lib/utils.js
================
import { clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs) {
  return twMerge(clsx(inputs))
}

export const downloadFile = (dataUrl, filename) => {
  const link = document.createElement('a');
  link.href = dataUrl;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

export const formatFileSize = (bytes) => {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
};

export const getImageDimensions = (file) => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      resolve({
        width: img.width,
        height: img.height
      });
    };
    img.onerror = reject;
    img.src = URL.createObjectURL(file);
  });
};

export const debounce = (func, wait) => {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
};

export const generateUniqueId = () => {
  return Date.now().toString(36) + Math.random().toString(36).substr(2);
};

================
File: src/main.jsx
================
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './app'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)

================
File: src/pages/Editor.jsx
================
import React, { useState, useRef } from 'react';
import ImageEditor from '../components/editor/ImageEditor';
import SaveProjectDialog from '../components/editor/SaveProjectDialog';
import ProjectsList from '../components/editor/ProjectsList';
import Adjustments from '../components/editor/Adjustments';
import ExportOptions from '../components/editor/ExportOptions';
import MultiImageManager from '../components/editor/MultiImageManager';
import { Button } from '../components/ui/button';
import { 
  Save, 
  Share, 
  Download, 
  FolderOpen, 
  X, 
  Plus, 
  ImageIcon 
} from 'lucide-react';
import useEditorStore from '../store/editorStore';
import useProjectStore from '../store/projectStore';
import * as Dialog from '@radix-ui/react-dialog';
import { quickDownload } from '../utils/image-export';

const Editor = () => {
  const [isSaveDialogOpen, setSaveDialogOpen] = useState(false);
  const [isProjectsDialogOpen, setProjectsDialogOpen] = useState(false);
  const [showImageManager, setShowImageManager] = useState(false);
  const canvasRef = useRef(null);
  
  const { currentImage } = useEditorStore();
  const { loadProject } = useProjectStore();

  const handleProjectSelect = async (project) => {
    try {
      await loadProject(project.id);
      setProjectsDialogOpen(false);
    } catch (error) {
      console.error('Error loading project:', error);
    }
  };

  const handleQuickDownload = async () => {
    if (!canvasRef.current) {
      console.error('Canvas reference not available');
      return;
    }

    try {
      await quickDownload(canvasRef.current);
    } catch (error) {
      console.error('Download failed:', error);
    }
  };

  return (
    <div className="h-full flex flex-col">
      {/* Toolbar */}
      <div className="bg-white border-b border-gray-200 px-4 py-2">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-2">
            <Button
              variant="outline"
              size="sm"
              className="flex items-center gap-2"
              onClick={() => setProjectsDialogOpen(true)}
            >
              <FolderOpen className="w-4 h-4" />
              Open Project
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="flex items-center gap-2"
              onClick={() => {
                useEditorStore.getState().clearImage();
                useProjectStore.getState().clearCurrentProject();
              }}
            >
              <Plus className="w-4 h-4" />
              New Project
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="flex items-center gap-2"
              onClick={() => setSaveDialogOpen(true)}
              disabled={!currentImage}
            >
              <Save className="w-4 h-4" />
              Save Project
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="flex items-center gap-2"
              onClick={() => setShowImageManager(!showImageManager)}
            >
              <ImageIcon className="w-4 h-4" />
              Manage Images
            </Button>
          </div>

          <div className="flex items-center space-x-2">
            <Button
              variant="outline"
              size="sm"
              className="flex items-center gap-2"
              onClick={handleQuickDownload}
              disabled={!currentImage}
            >
              <Download className="w-4 h-4" />
              Quick Download
            </Button>
          </div>
        </div>
      </div>

      {/* Main Editor Area */}
      <div className="flex-1 overflow-hidden">
        <div className="h-full flex">
          {/* Left Sidebar - Image Manager */}
          {showImageManager && (
            <div className="w-80 border-r border-gray-200 bg-gray-50 p-4 overflow-y-auto">
              <MultiImageManager />
            </div>
          )}

          {/* Main Canvas Area */}
          <div className="flex-1 p-4">
            <ImageEditor canvasRef={canvasRef} />
          </div>

          {/* Right Sidebar */}
          <div className="w-80 border-l border-gray-200 bg-gray-50 p-4 overflow-y-auto">
            <div className="space-y-6">
              <Adjustments />
              <ExportOptions canvasRef={canvasRef} />
            </div>
          </div>
        </div>
      </div>

      {/* Dialogs */}
      <SaveProjectDialog
        open={isSaveDialogOpen}
        onOpenChange={setSaveDialogOpen}
      />

      <Dialog.Root open={isProjectsDialogOpen} onOpenChange={setProjectsDialogOpen}>
        <Dialog.Portal>
          <Dialog.Overlay className="fixed inset-0 bg-black/50" />
          <Dialog.Content className="fixed left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-full max-w-2xl bg-white rounded-lg shadow-xl">
            <div className="flex items-center justify-between p-6 border-b border-gray-200">
              <Dialog.Title className="text-lg font-semibold">
                Open Project
              </Dialog.Title>
              <Dialog.Close className="rounded-full p-1.5 hover:bg-gray-100">
                <X className="h-4 w-4" />
              </Dialog.Close>
            </div>

            <div className="p-6 max-h-[60vh] overflow-y-auto">
              <ProjectsList onProjectSelect={handleProjectSelect} />
            </div>

            <div className="flex justify-end gap-3 p-6 border-t border-gray-200">
              <Button
                variant="outline"
                onClick={() => setProjectsDialogOpen(false)}
              >
                Cancel
              </Button>
            </div>
          </Dialog.Content>
        </Dialog.Portal>
      </Dialog.Root>
    </div>
  );
};

export default Editor;

================
File: src/pages/Home.jsx
================
import React from 'react';
import { useNavigate } from 'react-router-dom';
import { Button } from '../components/ui/button';
import { Upload, Image as ImageIcon, Save } from 'lucide-react';
import useEditorStore from '../store/editorStore';
import useProjectStore from '../store/projectStore';

const Home = () => {
  const navigate = useNavigate();
  const clearImage = useEditorStore((state) => state.clearImage);
  const clearCurrentProject = useProjectStore((state) => state.clearCurrentProject);

  const handleStartNewProject = () => {
    // Clear any existing image and project state
    clearImage();
    clearCurrentProject();
    navigate('/editor');
  };

  return (
    <div className="container mx-auto px-4 py-8">
      {/* Hero Section */}
      <div className="text-center mb-12">
        <h1 className="text-4xl font-bold text-gray-900 mb-4">
          Welcome to Mom's Watermarker
        </h1>
        <p className="text-xl text-gray-600 mb-8">
          Easily add watermarks to your images and protect your creative work
        </p>
        <div className="flex justify-center gap-4">
          <Button 
            onClick={handleStartNewProject}
            className="flex items-center gap-2"
          >
            <Upload className="w-5 h-5" />
            Start New Project
          </Button>
          <Button 
            variant="outline" 
            onClick={() => navigate('/templates')}
            className="flex items-center gap-2"
          >
            <Save className="w-5 h-5" />
            View Templates
          </Button>
        </div>
      </div>

      {/* Features Grid */}
      <div className="grid md:grid-cols-3 gap-8 mt-12">
        <FeatureCard
          icon={<Upload className="w-8 h-8" />}
          title="Easy Upload"
          description="Drag and drop your images or select them from your computer"
        />
        <FeatureCard
          icon={<ImageIcon className="w-8 h-8" />}
          title="Customizable Watermarks"
          description="Create and save custom watermarks for future use"
        />
        <FeatureCard
          icon={<Save className="w-8 h-8" />}
          title="Save Templates"
          description="Save your favorite watermark designs as templates"
        />
      </div>
    </div>
  );
};

const FeatureCard = ({ icon, title, description }) => {
  return (
    <div className="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
      <div className="text-blue-500 mb-4">{icon}</div>
      <h3 className="text-lg font-semibold text-gray-900 mb-2">{title}</h3>
      <p className="text-gray-600">{description}</p>
    </div>
  );
};

export default Home;

================
File: src/pages/SavedProjects.jsx
================
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import ProjectsList from '../components/editor/ProjectsList';
import { Button } from '../components/ui/button';
import { Plus, Search } from 'lucide-react';
import { Input } from '../components/ui/input';

const SavedProjects = () => {
  const navigate = useNavigate();
  const [searchQuery, setSearchQuery] = useState('');

  const handleProjectSelect = (project) => {
    navigate('/editor', { state: { projectId: project.id } });
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold text-gray-900">Saved Projects</h1>
        <Button 
          onClick={() => navigate('/editor')}
          className="flex items-center gap-2"
        >
          <Plus className="w-4 h-4" />
          New Project
        </Button>
      </div>

      <div className="mb-6">
        <div className="relative">
          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4" />
          <Input
            type="text"
            placeholder="Search projects..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="pl-10"
          />
        </div>
      </div>

      <ProjectsList 
        onProjectSelect={handleProjectSelect}
        searchQuery={searchQuery}
      />
    </div>
  );
};

export default SavedProjects;

================
File: src/pages/Settings.jsx
================
import React from 'react';
import { Button } from '../components/ui/button';
import { Input } from '../components/ui/input';
import { Save, User, Image, Download } from 'lucide-react';

const Settings = () => {
  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-2xl font-bold text-gray-900 mb-8">Settings</h1>

      <div className="space-y-8 max-w-2xl">
        {/* User Preferences */}
        <section className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
          <h2 className="text-lg font-semibold text-gray-900 mb-4 flex items-center gap-2">
            <User className="w-5 h-5" />
            User Preferences
          </h2>
          
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Default Watermark Text
              </label>
              <Input type="text" placeholder="© Your Name" />
            </div>
            
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Default Font Family
              </label>
              <select className="w-full rounded-md border border-gray-300 py-2 px-3">
                <option>Arial</option>
                <option>Times New Roman</option>
                <option>Helvetica</option>
              </select>
            </div>
          </div>
        </section>

        {/* Image Settings */}
        <section className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
          <h2 className="text-lg font-semibold text-gray-900 mb-4 flex items-center gap-2">
            <Image className="w-5 h-5" />
            Image Settings
          </h2>
          
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Default Image Quality
              </label>
              <select className="w-full rounded-md border border-gray-300 py-2 px-3">
                <option>High (100%)</option>
                <option>Medium (80%)</option>
                <option>Low (60%)</option>
              </select>
            </div>
            
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Default Export Format
              </label>
              <select className="w-full rounded-md border border-gray-300 py-2 px-3">
                <option>PNG</option>
                <option>JPEG</option>
                <option>WebP</option>
              </select>
            </div>
          </div>
        </section>

        {/* Export Settings */}
        <section className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
          <h2 className="text-lg font-semibold text-gray-900 mb-4 flex items-center gap-2">
            <Download className="w-5 h-5" />
            Export Settings
          </h2>
          
          <div className="space-y-4">
            <div className="flex items-center">
              <input type="checkbox" id="autoSave" className="mr-2" />
              <label htmlFor="autoSave" className="text-sm text-gray-700">
                Auto-save projects
              </label>
            </div>
            
            <div className="flex items-center">
              <input type="checkbox" id="preserveMetadata" className="mr-2" />
              <label htmlFor="preserveMetadata" className="text-sm text-gray-700">
                Preserve image metadata
              </label>
            </div>
          </div>
        </section>

        <div>
          <Button className="flex items-center gap-2">
            <Save className="w-4 h-4" />
            Save Settings
          </Button>
        </div>
      </div>
    </div>
  );
};

export default Settings;

================
File: src/pages/Templates.jsx
================
import React from 'react';
import { Plus, Edit, Trash } from 'lucide-react';
import { Button } from '../components/ui/button';

const Templates = () => {
  // Mock data for templates
  const templates = [
    { id: 1, name: 'Basic Watermark', lastUsed: '2024-12-29' },
    { id: 2, name: 'Copyright Text', lastUsed: '2024-12-28' },
    { id: 3, name: 'Logo Overlay', lastUsed: '2024-12-27' },
  ];

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex justify-between items-center mb-8">
        <h1 className="text-2xl font-bold text-gray-900">Watermark Templates</h1>
        <Button className="flex items-center gap-2">
          <Plus className="w-4 h-4" />
          New Template
        </Button>
      </div>

      <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-6">
        {templates.map((template) => (
          <div
            key={template.id}
            className="bg-white rounded-lg shadow-sm border border-gray-200 p-4"
          >
            <div className="flex items-center justify-between mb-4">
              <h3 className="text-lg font-semibold text-gray-900">{template.name}</h3>
              <div className="flex items-center gap-2">
                <Button variant="ghost" size="icon">
                  <Edit className="w-4 h-4" />
                </Button>
                <Button variant="ghost" size="icon" className="text-red-500">
                  <Trash className="w-4 h-4" />
                </Button>
              </div>
            </div>
            
            <div className="h-32 bg-gray-100 rounded-md mb-4 flex items-center justify-center">
              <span className="text-gray-500">Preview</span>
            </div>
            
            <div className="text-sm text-gray-500">
              Last used: {template.lastUsed}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

export default Templates;

================
File: src/services/projectService.js
================
import { generateUniqueId } from '../lib/utils';

export const saveProject = async (project) => {
  try {
    // Get existing projects from localStorage
    const existingProjects = JSON.parse(localStorage.getItem('watermark-projects') || '[]');
    
    // Generate unique ID for new project if it doesn't have one
    const projectToSave = {
      ...project,
      id: project.id || generateUniqueId(),
      lastModified: new Date().toISOString(),
    };

    // Update existing project or add new one
    const updatedProjects = project.id 
      ? existingProjects.map(p => p.id === project.id ? projectToSave : p)
      : [...existingProjects, projectToSave];

    // Save to localStorage
    localStorage.setItem('watermark-projects', JSON.stringify(updatedProjects));
    
    return projectToSave;
  } catch (error) {
    console.error('Error saving project:', error);
    throw new Error('Failed to save project');
  }
};

export const loadProject = async (projectId) => {
  try {
    const projects = JSON.parse(localStorage.getItem('watermark-projects') || '[]');
    const project = projects.find(p => p.id === projectId);
    
    if (!project) {
      throw new Error('Project not found');
    }

    return project;
  } catch (error) {
    console.error('Error loading project:', error);
    throw new Error('Failed to load project');
  }
};

export const getAllProjects = async () => {
  try {
    return JSON.parse(localStorage.getItem('watermark-projects') || '[]');
  } catch (error) {
    console.error('Error getting projects:', error);
    throw new Error('Failed to get projects');
  }
};

export const deleteProject = async (projectId) => {
  try {
    const projects = JSON.parse(localStorage.getItem('watermark-projects') || '[]');
    const updatedProjects = projects.filter(p => p.id !== projectId);
    localStorage.setItem('watermark-projects', JSON.stringify(updatedProjects));
  } catch (error) {
    console.error('Error deleting project:', error);
    throw new Error('Failed to delete project');
  }
};

================
File: src/store/editorStore.js
================
import { create } from 'zustand';

const useEditorStore = create((set, get) => ({
  // Current image being edited
  currentImage: null,
  
  // All images in the project
  projectImages: [],
  
  // Editor settings
  settings: {
    brightness: 100,
    contrast: 100,
    saturation: 100,
    rotation: 0,
    scale: 100,
    isCropping: false,
    cropBox: { x: 0, y: 0, width: 0, height: 0 },
  },
  
  // Watermark settings
  watermark: {
    text: '',
    font: 'Arial',
    size: 24,
    color: '#ffffff',
    opacity: 0.8,
    position: { x: 50, y: 50 },
    rotation: 0,
    alignment: 'center',
    enableShadow: true,
    shadowOpacity: 0.5,
  },
  
  // Actions
  setCurrentImage: (image) => set({ currentImage: image }),
  
  addImages: (newImages) => 
    set((state) => ({
      projectImages: [...state.projectImages, ...newImages]
    })),
    
  removeImage: (index) =>
    set((state) => ({
      projectImages: state.projectImages.filter((_, i) => i !== index),
      currentImage: state.currentImage === state.projectImages[index] 
        ? null 
        : state.currentImage
    })),
    
  clearImages: () =>
    set({
      projectImages: [],
      currentImage: null
    }),
  
  updateSettings: (newSettings) => 
    set((state) => ({
      settings: { ...state.settings, ...newSettings }
    })),
    
  updateWatermark: (newWatermarkSettings) =>
    set((state) => ({
      watermark: { ...state.watermark, ...newWatermarkSettings }
    })),
    
  resetSettings: () =>
    set({
      settings: {
        brightness: 100,
        contrast: 100,
        saturation: 100,
        rotation: 0,
        scale: 100,
      }
    }),
    
  resetWatermark: () =>
    set({
      watermark: {
        text: '',
        font: 'Arial',
        size: 24,
        color: '#ffffff',
        opacity: 0.8,
        position: { x: 50, y: 50 },
        rotation: 0,
        alignment: 'center',
        enableShadow: true,
        shadowOpacity: 0.5,
      }
    }),
    
  clearImage: () =>
    set({
      currentImage: null,
      settings: {
        brightness: 100,
        contrast: 100,
        saturation: 100,
        rotation: 0,
        scale: 100,
      }
    }),
}));

export default useEditorStore;

================
File: src/store/projectStore.js
================
import { create } from 'zustand';
import { saveProject, loadProject, getAllProjects, deleteProject } from '../services/projectService';

const useProjectStore = create((set, get) => ({
  // State
  projects: [],
  currentProject: null,
  isLoading: false,
  error: null,

  // Actions
  fetchProjects: async () => {
    set({ isLoading: true, error: null });
    try {
      const projects = await getAllProjects();
      set({ projects, isLoading: false });
    } catch (error) {
      set({ error: error.message, isLoading: false });
    }
  },

  createProject: async (projectData) => {
    set({ isLoading: true, error: null });
    try {
      const newProject = {
        ...projectData,
        createdAt: new Date().toISOString(),
        lastModified: new Date().toISOString(),
      };
      const savedProject = await saveProject(newProject);
      set(state => ({
        projects: [...state.projects, savedProject],
        currentProject: savedProject,
        isLoading: false,
      }));
      return savedProject;
    } catch (error) {
      set({ error: error.message, isLoading: false });
      throw error;
    }
  },

  updateProject: async (projectId, updates) => {
    set({ isLoading: true, error: null });
    try {
      const currentProject = get().projects.find(p => p.id === projectId);
      if (!currentProject) throw new Error('Project not found');

      const updatedProject = {
        ...currentProject,
        ...updates,
        lastModified: new Date().toISOString(),
      };

      const savedProject = await saveProject(updatedProject);
      set(state => ({
        projects: state.projects.map(p => 
          p.id === projectId ? savedProject : p
        ),
        currentProject: savedProject,
        isLoading: false,
      }));
      return savedProject;
    } catch (error) {
      set({ error: error.message, isLoading: false });
      throw error;
    }
  },

  loadProject: async (projectId) => {
    set({ isLoading: true, error: null });
    try {
      const project = await loadProject(projectId);
      set({ currentProject: project, isLoading: false });
      return project;
    } catch (error) {
      set({ error: error.message, isLoading: false });
      throw error;
    }
  },

  deleteProject: async (projectId) => {
    set({ isLoading: true, error: null });
    try {
      await deleteProject(projectId);
      set(state => ({
        projects: state.projects.filter(p => p.id !== projectId),
        currentProject: state.currentProject?.id === projectId 
          ? null 
          : state.currentProject,
        isLoading: false,
      }));
    } catch (error) {
      set({ error: error.message, isLoading: false });
      throw error;
    }
  },

  clearCurrentProject: () => {
    set({ currentProject: null });
  },
}));

export default useProjectStore;

================
File: src/store/userStore.js
================
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

const useUserStore = create(
  persist(
    (set) => ({
      // User preferences
      preferences: {
        defaultWatermarkText: '© Your Name',
        defaultFont: 'Arial',
        defaultImageQuality: 80,
        defaultExportFormat: 'PNG',
        autoSave: true,
        preserveMetadata: true,
      },
      
      // Recent projects
      recentProjects: [],
      
      // Actions
      updatePreferences: (newPreferences) =>
        set((state) => ({
          preferences: { ...state.preferences, ...newPreferences }
        })),
        
      addRecentProject: (project) =>
        set((state) => ({
          recentProjects: [
            { ...project, timestamp: Date.now() },
            ...state.recentProjects
          ].slice(0, 10) // Keep only last 10 projects
        })),
        
      clearRecentProjects: () =>
        set({ recentProjects: [] }),
        
      resetPreferences: () =>
        set({
          preferences: {
            defaultWatermarkText: '© Your Name',
            defaultFont: 'Arial',
            defaultImageQuality: 80,
            defaultExportFormat: 'PNG',
            autoSave: true,
            preserveMetadata: true,
          }
        }),
    }),
    {
      name: 'user-preferences', // localStorage key
    }
  )
);

export default useUserStore;

================
File: src/store/watermarkStore.js
================
import { create } from 'zustand';

const useWatermarkStore = create((set) => ({
  // Saved watermark templates
  templates: [],
  
  // Currently selected template
  currentTemplate: null,
  
  // Template being edited
  editingTemplate: null,
  
  // Actions
  addTemplate: (template) =>
    set((state) => ({
      templates: [...state.templates, { ...template, id: Date.now() }]
    })),
    
  updateTemplate: (id, updatedTemplate) =>
    set((state) => ({
      templates: state.templates.map((template) =>
        template.id === id ? { ...template, ...updatedTemplate } : template
      )
    })),
    
  deleteTemplate: (id) =>
    set((state) => ({
      templates: state.templates.filter((template) => template.id !== id)
    })),
    
  setCurrentTemplate: (template) =>
    set({ currentTemplate: template }),
    
  setEditingTemplate: (template) =>
    set({ editingTemplate: template }),
    
  clearEditingTemplate: () =>
    set({ editingTemplate: null }),
}));

export default useWatermarkStore;

================
File: src/utils/image-export.js
================
import { downloadFile } from '../lib/utils';

export const exportImageWithSettings = async (canvas, settings = {}) => {
  if (!canvas) {
    throw new Error('No canvas element provided');
  }

  try {
    // Determine the MIME type based on format
    const mimeTypes = {
      'png': 'image/png',
      'jpeg': 'image/jpeg',
      'webp': 'image/webp'
    };
    const mimeType = mimeTypes[settings.format?.toLowerCase()] || 'image/png';
    
    // For PNG, quality is ignored as it's lossless
    const quality = settings.format?.toLowerCase() === 'png' ? 1 : (settings.quality || 80) / 100;
    
    // Get the data URL from canvas
    const dataUrl = canvas.toDataURL(mimeType, quality);
    
    // Generate filename with extension
    const filename = `${settings.filename || 'watermarked-image'}.${settings.format?.toLowerCase() || 'png'}`;
    
    // Download the file
    downloadFile(dataUrl, filename);
    
    return { success: true, filename };
  } catch (error) {
    console.error('Error exporting image:', error);
    throw new Error('Failed to export image');
  }
};

export const quickDownload = async (canvas) => {
  if (!canvas) {
    throw new Error('No canvas element provided');
  }

  try {
    // Use PNG format for quick downloads
    const dataUrl = canvas.toDataURL('image/png');
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `watermarked-image-${timestamp}.png`;
    
    downloadFile(dataUrl, filename);
    
    return { success: true, filename };
  } catch (error) {
    console.error('Error downloading image:', error);
    throw new Error('Failed to download image');
  }
};

export const applyWatermarkToMultipleImages = async (images, watermarkSettings) => {
  const results = [];
  
  for (const imageData of images) {
    try {
      // Create a temporary canvas for each image
      const tempCanvas = document.createElement('canvas');
      const ctx = tempCanvas.getContext('2d');
      const img = new Image();
      
      // Load the image and process it
      await new Promise((resolve, reject) => {
        img.onload = () => {
          // Set canvas dimensions to match image
          tempCanvas.width = img.width;
          tempCanvas.height = img.height;
          
          // Draw the image
          ctx.drawImage(img, 0, 0);
          
          // Apply watermark
          if (watermarkSettings?.text) {
            applyWatermark(tempCanvas, watermarkSettings);
          }
          
          resolve();
        };
        img.onerror = reject;
        img.src = imageData;
      });
      
      // Get the processed image data
      const processedImageData = tempCanvas.toDataURL('image/png');
      results.push({
        success: true,
        data: processedImageData
      });
    } catch (error) {
      console.error('Error processing image:', error);
      results.push({
        success: false,
        error: error.message
      });
    }
  }
  
  return results;
};

================
File: src/utils/imageProcessing.js
================
// Image processing utilities for handling images, watermarks, and adjustments

export const processImage = async (file) => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (event) => {
        const img = new Image();
        img.onload = () => {
          resolve(img);
        };
        img.onerror = reject;
        img.src = event.target.result;
      };
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  };
  
  export const applyWatermark = (canvas, watermarkSettings) => {
    const ctx = canvas.getContext('2d');
    const {
      text,
      font,
      size,
      color,
      opacity,
      position,
      rotation,
      alignment,
      enableShadow,
      shadowOpacity
    } = watermarkSettings;
  
    if (!text) return;
  
    // Save current context state
    ctx.save();
  
    // Set watermark style
    ctx.globalAlpha = opacity;
    ctx.font = `${size}px ${font}`;
    ctx.fillStyle = color;
    ctx.textBaseline = 'middle';
  
    // Calculate text metrics
    const metrics = ctx.measureText(text);
    const textWidth = metrics.width;
    const actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
    
    // Calculate position based on alignment and position settings
    let x = (canvas.width * position.x) / 100;
    let y = (canvas.height * position.y) / 100;
  
    // Adjust x position based on alignment
    switch (alignment) {
      case 'left':
        break;
      case 'center':
        x -= textWidth / 2;
        break;
      case 'right':
        x -= textWidth;
        break;
    }
  
    // Set up rotation if needed
    if (rotation !== 0) {
      // Move to rotation center point
      ctx.translate(x + textWidth / 2, y);
      // Rotate
      ctx.rotate((rotation * Math.PI) / 180);
      // Move back
      ctx.translate(-(x + textWidth / 2), -y);
    }
  
    // Apply shadow if enabled
    if (enableShadow) {
      ctx.shadowColor = `rgba(0, 0, 0, ${shadowOpacity})`;
      ctx.shadowBlur = size / 8;
      ctx.shadowOffsetX = size / 16;
      ctx.shadowOffsetY = size / 16;
    }
  
    // Draw the watermark text
    ctx.fillText(text, x, y);
  
    // Restore context state
    ctx.restore();
  };
  
  export const applyImageAdjustments = (canvas, settings) => {
    const ctx = canvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
  
    const brightness = settings.brightness / 100;
    const contrast = settings.contrast / 100;
    const saturation = settings.saturation / 100;
  
    // Create a lookup table for faster processing
    const brightnessLookup = new Uint8Array(256);
    const contrastLookup = new Uint8Array(256);
    
    for (let i = 0; i < 256; i++) {
      brightnessLookup[i] = Math.min(255, Math.max(0, i * brightness));
      contrastLookup[i] = Math.min(255, Math.max(0, 
        ((i - 128) * contrast + 128)));
    }
  
    for (let i = 0; i < data.length; i += 4) {
      // Apply brightness and contrast using lookup tables
      data[i] = contrastLookup[brightnessLookup[data[i]]];       // R
      data[i + 1] = contrastLookup[brightnessLookup[data[i + 1]]]; // G
      data[i + 2] = contrastLookup[brightnessLookup[data[i + 2]]]; // B
  
      // Apply saturation
      if (saturation !== 1) {
        const gray = 0.2989 * data[i] + 0.5870 * data[i + 1] + 0.1140 * data[i + 2];
        data[i] = Math.min(255, Math.max(0, gray + (data[i] - gray) * saturation));
        data[i + 1] = Math.min(255, Math.max(0, gray + (data[i + 1] - gray) * saturation));
        data[i + 2] = Math.min(255, Math.max(0, gray + (data[i + 2] - gray) * saturation));
      }
    }
  
    ctx.putImageData(imageData, 0, 0);
  };
  
  export const rotateImage = (canvas, angle) => {
    const ctx = canvas.getContext('2d');
    
    // Create a temporary canvas
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    
    // Set the temporary canvas to the same size
    tempCanvas.width = canvas.width;
    tempCanvas.height = canvas.height;
    
    // Copy the original image to the temporary canvas
    tempCtx.drawImage(canvas, 0, 0);
    
    // Clear the original canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Calculate new dimensions if needed
    let newWidth = canvas.width;
    let newHeight = canvas.height;
    
    if (angle === 90 || angle === 270) {
      // Swap dimensions for 90° or 270° rotation
      canvas.width = newHeight;
      canvas.height = newWidth;
    }
    
    // Rotate and draw
    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.rotate((angle * Math.PI) / 180);
    ctx.drawImage(
      tempCanvas,
      -tempCanvas.width / 2,
      -tempCanvas.height / 2
    );
    ctx.restore();
  };
  
  export const resizeImage = (canvas, scale) => {
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    const scaleValue = scale / 100;
    
    // Store original dimensions
    const originalWidth = canvas.width;
    const originalHeight = canvas.height;
    
    // Copy original image
    tempCanvas.width = originalWidth;
    tempCanvas.height = originalHeight;
    tempCtx.drawImage(canvas, 0, 0);
    
    // Set new dimensions
    canvas.width = Math.round(originalWidth * scaleValue);
    canvas.height = Math.round(originalHeight * scaleValue);
    
    // Draw resized image
    const ctx = canvas.getContext('2d');
    ctx.drawImage(
      tempCanvas,
      0, 0,
      originalWidth, originalHeight,
      0, 0,
      canvas.width, canvas.height
    );
  };
  
  export const exportImage = (canvas, format = 'png', quality = 0.8) => {
    // Determine the MIME type
    const mimeTypes = {
      'png': 'image/png',
      'jpeg': 'image/jpeg',
      'webp': 'image/webp'
    };
  
    const mimeType = mimeTypes[format.toLowerCase()] || 'image/png';
    
    // For PNG, quality is ignored as it's lossless
    if (format.toLowerCase() === 'png') {
      return canvas.toDataURL(mimeType);
    }
    
    // For JPEG and WebP, apply quality setting
    return canvas.toDataURL(mimeType, quality);
  };
  
  export const createThumbnail = async (image, maxWidth = 300, maxHeight = 300) => {
    return new Promise((resolve) => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
  
      // Calculate thumbnail dimensions while maintaining aspect ratio
      let width = image.width;
      let height = image.height;
      
      if (width > height) {
        if (width > maxWidth) {
          height = Math.round((height * maxWidth) / width);
          width = maxWidth;
        }
      } else {
        if (height > maxHeight) {
          width = Math.round((width * maxHeight) / height);
          height = maxHeight;
        }
      }
  
      // Set canvas dimensions
      canvas.width = width;
      canvas.height = height;
  
      // Draw thumbnail
      ctx.drawImage(image, 0, 0, width, height);
      
      // Convert to data URL
      resolve(canvas.toDataURL('image/jpeg', 0.7));
    });
  };
  
  export const applyFilter = (canvas, filterType) => {
    const ctx = canvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
  
    switch (filterType) {
      case 'grayscale':
        for (let i = 0; i < data.length; i += 4) {
          const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
          data[i] = gray;     // R
          data[i + 1] = gray; // G
          data[i + 2] = gray; // B
        }
        break;
  
      case 'sepia':
        for (let i = 0; i < data.length; i += 4) {
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          
          data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));     // R
          data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168)); // G
          data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131)); // B
        }
        break;
  
      case 'invert':
        for (let i = 0; i < data.length; i += 4) {
          data[i] = 255 - data[i];         // R
          data[i + 1] = 255 - data[i + 1]; // G
          data[i + 2] = 255 - data[i + 2]; // B
        }
        break;
  
      default:
        return;
    }
  
    ctx.putImageData(imageData, 0, 0);
  };

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
    content: [
      "./index.html",
      "./src/**/*.{js,ts,jsx,tsx}",
    ],
    theme: {
      extend: {
        colors: {
          primary: {
            DEFAULT: '#3b82f6',
            foreground: '#ffffff',
          },
          secondary: {
            DEFAULT: '#6b7280',
            foreground: '#ffffff',
          },
          destructive: {
            DEFAULT: '#ef4444',
            foreground: '#ffffff',
          },
          muted: {
            DEFAULT: '#f3f4f6',
            foreground: '#6b7280',
          },
          accent: {
            DEFAULT: '#f3f4f6',
            foreground: '#1f2937',
          },
        },
      },
    },
    plugins: [],
  }

================
File: vite.config.js
================
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  build: {
    rollupOptions: {
      input: {
        main: path.resolve(__dirname, 'index.html'),
      },
    },
  },
  optimizeDeps: {
    include: [
      'react',
      'react-dom',
      'react-router-dom',
      'lucide-react',
      '@radix-ui/react-dialog',
      '@radix-ui/react-progress',
      '@radix-ui/react-slider',
    ],
  },
});
